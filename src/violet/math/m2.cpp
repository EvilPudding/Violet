// ============================================================================

#include <cmath>

#include "violet/math/m2.h"

using namespace vlt;

// ============================================================================

r32 & m2::row::operator[](const size_t i)
{
	return columns[i];
}

// ----------------------------------------------------------------------------

const r32 & m2::row::operator[](const size_t i) const
{
	return columns[i];
}

// ============================================================================

const m2 m2::Identity(1, 0, 0, 1);
const m2 m2::Zero;

// ============================================================================

m2::m2() :
	a(0),
	b(0),
	c(0),
	d(0)
{
}

// ----------------------------------------------------------------------------

m2::m2(r32 _a, r32 _b, r32 _c, r32 _d) :
	a(_a),
	b(_b),
	c(_c),
	d(_d)
{
}

// ----------------------------------------------------------------------------

m2::m2(const r32 rotation) :
	m2()
{
	a = std::cos(rotation);
	b = -std::sin(rotation);
	c = std::sin(rotation);
	d = std::cos(rotation);
}

// ----------------------------------------------------------------------------

m2 m2::inverse() const
{
	const r32 dt = determinant();
	return dt != 0 ? m2(d, -b, -c, a) / dt : Identity;
}

// ----------------------------------------------------------------------------

r32 m2::determinant() const
{
	return a * d - c * b;
}

// ----------------------------------------------------------------------------

m2 & m2::operator/=(const r32 scale)
{
	a /= scale;
	b /= scale;
	c /= scale;
	d /= scale;
	return *this;
}

// ============================================================================

v2 vlt::operator*(const m2 & mat, const v2 & vec)
{
	return v2(vec.x * mat.a + vec.y * mat.b, vec.x * mat.c + vec.y * mat.d);
}

// ----------------------------------------------------------------------------

m2 vlt::operator/(m2 mat, const r32 scale)
{
	return mat /= scale;
}

// ----------------------------------------------------------------------------

bool vlt::operator==(const m2 & lhs, const m2 & rhs)
{
	return lhs.a == rhs.a && lhs.b == rhs.b && lhs.c == rhs.c && lhs.d == rhs.d;
}

// ----------------------------------------------------------------------------

std::ostream & vlt::operator<<(std::ostream & os, const m2 & mat)
{
	return os << "|" << mat.a << "," << mat.b << "|" << mat.c << "," << mat.d << "|";
}

// ============================================================================
